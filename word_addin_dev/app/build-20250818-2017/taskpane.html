<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Contract AI - Draft Assistant</title>
  <style>
    :root { --bg:#0f1a24; --card:#142231; --muted:#7c8b9a; --btn:#f6b93b; --btn2:#2d89ef; --text:#e9f1f7; }
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font-family:Segoe UI,Arial,sans-serif}
    .wrap{padding:12px}
    .row{margin:10px 0}
    .card{background:var(--card);border-radius:8px;padding:10px}
    .flex{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    input,textarea,select{width:100%;box-sizing:border-box;border:1px solid #213345;border-radius:6px;background:#09131b;color:var(--text);padding:8px}
    textarea{min-height:110px;resize:vertical}
    button{border:0;border-radius:6px;padding:8px 12px;cursor:pointer}
    .btn{background:var(--btn);color:#111}
    .btn2{background:var(--btn2);color:white}
    .btn-grey{background:#394b5b;color:#e3eef7}
    .badge{display:inline-block;padding:3px 8px;border-radius:999px;background:#0d2536;color:#d1e5f6;font-size:12px;margin-right:6px}
    .muted{color:var(--muted);font-size:12px}
    .pill{display:inline-block;background:#153247;border:1px solid #20435a;border-radius:999px;padding:2px 8px;font-size:12px;color:#cfe7f7}
    #console{background:#0b1822;border-radius:8px;padding:8px;white-space:pre-wrap;max-height:170px;overflow:auto;border:1px dashed #234}
    .topline{display:flex;justify-content:space-between;align-items:center}
    .list{margin:0;padding-left:18px}
    .list li{margin:4px 0}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .kv{display:flex;gap:6px;align-items:center}
    .kv span{font-size:12px}
    pre{background:#0b1822;border:1px solid #234;border-radius:8px;padding:8px;overflow:auto;max-height:220px}
    .toggle{cursor:pointer;text-decoration:underline}
    .right{margin-left:auto}
    .inline{display:inline-flex;gap:6px;align-items:center;flex-wrap:wrap}
    .sep{height:1px;background:#1b2b3a;margin:8px 0}
    /* Suggest list */
    .sug-card{border:1px solid #1b2b3a;border-radius:8px;padding:8px;margin:6px 0;background:#0b1822}
    .sug-head{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
    .sug-title{font-weight:600}
    .sug-meta{font-size:12px;color:#9fb4c6}
  </style>

  <!-- Office.js -->
  <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js" defer></script>

  <!-- Boot: load external bundle if present -->
  <script>
  (function () {
    var u = new URL(window.location.href);
    var v = u.searchParams.get("v") || ("build-" + Date.now());
    var s = document.createElement("script");
    s.defer = true;
    s.src = "taskpane.bundle.js?v=" + encodeURIComponent(v);
    document.head.appendChild(s);
    s.onerror = function () {
      var f = document.createElement("script");
      f.defer = true;
      f.src = "./taskpane.bundle.js";
      document.head.appendChild(f);
      var c = document.getElementById("console");
      if (c) c.textContent += "[BOOT] primary bundle failed, loading fallback\n";
    };
    window.__BUILD_ID__ = v;
  })();
  </script>
</head>
<body>
<div class="wrap">
  <div class="topline">
    <h3 style="margin:6px 0;">Contract AI - Draft Assistant</h3>
    <span class="pill">Build: <span id="buildInfo"></span></span>
  </div>

  <div class="row muted">Endpoints: <code>/health</code> · <code>/api/analyze</code> · <code>/api/gpt/draft</code> · <code>/api/qa-recheck</code></div>

  <div class="row card">
    <div class="row"><input id="backendInput" placeholder="http://127.0.0.1:9000" /></div>
    <div class="row flex">
      <button id="btnSave" class="btn-grey">Save</button>
      <button id="btnTest" class="btn-grey">Test</button>
      <span class="pill" id="connBadge">Conn: —</span>
      <span class="pill" id="officeBadge">Office: —</span>
      <span class="pill right" id="doctorToggle">Doctor ▸</span>
    </div>
    <div id="statusLine" class="muted">
      <span class="inline">
        <span>cid:</span><span class="badge" id="cidBadge">—</span>
        <span>X-Cache:</span><span class="badge" id="xcacheBadge">—</span>
        <span>latency:</span><span class="badge" id="latencyBadge">—</span>
        <span>schema:</span><span class="badge" id="schemaBadge">—</span>
      </span>
    </div>
  </div>

  <div id="doctorPanel" class="row card" style="display:none">
    <div class="muted" style="margin-bottom:6px">Doctor</div>
    <div class="grid">
      <div class="kv"><strong>cid:</strong><span id="doctorCid">—</span></div>
      <div class="kv"><strong>last latency(ms):</strong><span id="doctorLatency">—</span></div>
    </div>
    <div class="row">
      <strong>Recent requests</strong>
      <ul class="list" id="doctorReqList"></ul>
    </div>
    <div class="row">
      <strong>Payload size</strong>
      <div class="muted" id="doctorPayload">—</div>
    </div>
  </div>

  <div id="officeTools" class="row card" style="display:block">
    <div class="muted" style="margin-bottom:6px">Office tools</div>
    <div class="flex">
      <button id="useSelection" class="btn-grey">Use selection →</button>
      <button id="useWholeDoc" class="btn-grey">Use whole doc →</button>
      <button id="btnInsertIntoWord" class="btn">Insert result into Word</button>
    </div>
  </div>

  <div id="annotateQA" class="row card">
    <div class="flex">
      <div class="kv"><strong>Annotate & QA</strong></div>
      <div class="kv">
        <span class="muted">Risk threshold:</span>
        <select id="riskThreshold">
          <option value="medium">medium</option>
          <option value="high" selected>high</option>
          <option value="critical">critical</option>
        </select>
      </div>
    </div>
    <div class="row flex" style="margin-top:6px">
      <button id="btnAnalyzeDoc" class="btn-grey">Analyze (doc)</button>
      <button id="btnAnnotate" class="btn2">Annotate</button>
      <button id="btnQARecheck" class="btn-grey">QA Recheck</button>
      <button id="btnClearAnnots" class="btn-grey">Clear Annotations</button>
      <span class="pill right" id="qaDeltaBadge" title="QA deltas">Δ: —</span>
    </div>
    <div id="qaResiduals" class="row" style="display:none">
      <strong>Residual risks</strong>
      <ul class="list" id="qaResidualList"></ul>
    </div>
  </div>

  <div class="row card">
    <div class="muted" style="margin-bottom:6px">Original clause:</div>
    <textarea id="originalClause" placeholder="Paste text or load from selection/document…"></textarea>
    <div class="row flex" style="margin-top:8px">
      <button id="analyzeBtn" class="btn-grey">Analyze</button>
      <button id="draftBtn" class="btn">Get AI Draft</button>
      <button id="copyResultBtn" class="btn-grey">Copy result</button>
    </div>
    <div class="row">
      <span class="badge" id="scoreBadge">score: —</span>
      <span class="badge" id="riskBadge">risk: —</span>
      <span class="badge" id="statusBadge">status: —</span>
      <span class="badge" id="severityBadge">severity: —</span>
    </div>
  </div>

  <div class="row card" id="resultsCard">
    <div class="muted" style="margin-bottom:6px">Results</div>
    <div class="grid">
      <div class="kv"><strong>Clause type:</strong><span id="resClauseType">—</span></div>
      <div class="kv"><strong>Findings:</strong><span id="resFindingsCount">—</span></div>
    </div>

    <div class="row">
      <strong>Findings</strong>
      <ul class="list" id="findingsList"></ul>
    </div>

    <div class="row">
      <strong>Recommendations</strong>
      <ul class="list" id="recsList"></ul>
    </div>

    <div class="row">
      <span class="toggle" id="toggleRaw">Show raw JSON</span>
      <pre id="rawJson" style="display:none"></pre>
    </div>
  </div>

  <div id="cai-suggest" class="card mt-2">
    <div class="card-header">Suggested edits</div>
    <div class="card-body">
      <div class="row" style="display:flex;gap:8px;align-items:flex-end;flex-wrap:wrap">
        <div style="flex:1">
          <label class="form-label">Clause</label>
          <select id="cai-clause-select" class="form-select"></select>
        </div>
        <div style="flex:1">
          <label class="form-label">Mode</label>
          <select id="cai-mode" class="form-select">
            <option value="friendly">friendly</option>
            <option value="strict">strict</option>
          </select>
        </div>
        <div class="col-auto d-flex align-items-end">
          <button id="cai-btn-suggest" class="btn btn-primary">Suggest</button>
        </div>
      </div>
      <div id="cai-suggest-list"></div>
    </div>
  </div>

  <div class="row card">
    <div class="muted" style="margin-bottom:6px">Proposed draft (from analysis or edited manually):</div>
    <textarea id="draftBox" placeholder="Will be filled from analysis.proposed_text if provided…"></textarea>
    <div class="row flex" style="margin-top:8px">
      <button id="btnPreview" class="btn-grey" disabled>Preview diff</button>
      <button id="btnApply" class="btn" disabled>Apply (tracked + comment)</button>
      <button id="acceptAllBtn" class="btn-grey" disabled>Accept all</button>
      <button id="rejectAllBtn" class="btn-grey" disabled>Reject all</button>
    </div>
  </div>

  <div class="row">
    <div class="muted" style="margin-bottom:4px">Console</div>
    <div id="console"></div>
  </div>
</div>

<!-- Fail-safe inline script (only wires handlers if bundle didn't) -->
<script>
(function(){
  if (window.__CAI_WIRED__ === 'ready') return; // guard against double-binding with bundle
  window.__CAI_WIRED__ = true;

  // ---------- Utilities ----------
  const els = {
    backend: document.getElementById('backendInput'),
    btnSave: document.getElementById('btnSave'),
    btnTest: document.getElementById('btnTest'),
    analyzeBtn: document.getElementById('analyzeBtn'),
    draftBtn: document.getElementById('draftBtn'),
    copyBtn: document.getElementById('copyResultBtn'),
    clause: document.getElementById('originalClause'),
    draft: document.getElementById('draftBox'),
    score: document.getElementById('scoreBadge'),
    risk: document.getElementById('riskBadge'),
    status: document.getElementById('statusBadge'),
    severity: document.getElementById('severityBadge'),
    resClauseType: document.getElementById('resClauseType'),
    resFindingsCount: document.getElementById('resFindingsCount'),
    findingsList: document.getElementById('findingsList'),
    recsList: document.getElementById('recsList'),
    toggleRaw: document.getElementById('toggleRaw'),
    rawJson: document.getElementById('rawJson'),
    useSel: document.getElementById('useSelection'),
    useDoc: document.getElementById('useWholeDoc'),
    insertWord: document.getElementById('btnInsertIntoWord'),
    btnAnalyzeDoc: document.getElementById('btnAnalyzeDoc'),
    btnAnnotate: document.getElementById('btnAnnotate'),
    btnQARecheck: document.getElementById('btnQARecheck'),
    btnClearAnnots: document.getElementById('btnClearAnnots'),
    qaDeltaBadge: document.getElementById('qaDeltaBadge'),
    qaResiduals: document.getElementById('qaResiduals'),
    qaResidualList: document.getElementById('qaResidualList'),
    riskThreshold: document.getElementById('riskThreshold'),
    buildInfo: document.getElementById('buildInfo'),
    doctorToggle: document.getElementById('doctorToggle'),
    doctorPanel: document.getElementById('doctorPanel'),
    doctorCid: document.getElementById('doctorCid'),
    doctorLatency: document.getElementById('doctorLatency'),
    doctorReqList: document.getElementById('doctorReqList'),
    doctorPayload: document.getElementById('doctorPayload'),
    cidBadge: document.getElementById('cidBadge'),
    xcacheBadge: document.getElementById('xcacheBadge'),
    latencyBadge: document.getElementById('latencyBadge'),
    schemaBadge: document.getElementById('schemaBadge'),
    connBadge: document.getElementById('connBadge'),
    officeBadge: document.getElementById('officeBadge'),
    sugSelect: document.getElementById('cai-clause-select'),
    sugMode: document.getElementById('cai-mode'),
    sugBtn: document.getElementById('cai-btn-suggest'),
    sugList: document.getElementById('cai-suggest-list'),
    btnPreview: document.getElementById('btnPreview'),
    btnApply: document.getElementById('btnApply'),
    btnAcceptAll: document.getElementById('acceptAllBtn'),
    btnRejectAll: document.getElementById('rejectAllBtn'),
    console: document.getElementById('console'),
  };

  const LS_KEY = 'contract_ai_backend';
  function readLS(k){ try { return localStorage.getItem(k)||'' } catch(e){ return '' } }
  function writeLS(k,v){ try { localStorage.setItem(k,v) } catch(e){} }
  function txt(el, s){ if(el) el.textContent = (s==null?'':String(s)); }
  function status(msg){ if(!els.console) return; const t=new Date().toLocaleTimeString(); els.console.textContent += `[${t}] ${msg}\n`; els.console.scrollTop = els.console.scrollHeight; }

  // State
  const S = {
    lastAnalyze: null,       // full envelope from /api/analyze
    lastLegacy: null,        // {analysis, results, clauses}
    lastDocument: null,      // SSOT document
    lastCid: null,
    lastLatency: null,
    clauseTitles: {},        // id -> title
  };

  // Backend URL (з нормалізацією під HTTPS-панель)
function normalizeBackend(v){
  v = (v || '').trim();
  if (!v) return '';
  if (!/^https?:\/\//i.test(v)) v = 'http://' + v;                // додай схему, якщо її немає
  // якщо панель працює по https, автопідніми localhost/127.0.0.1 до https
  if (location.protocol === 'https:' && /^http:\/\/(localhost|127\.0\.0\.1)(:\d+)?$/i.test(v)) {
    v = v.replace(/^http:/i, 'https:');
  }
  return v.replace(/\/+$/,'');                                    // прибери трейлінг слеші
}
function getBackend(){
  const def = (location.protocol === 'https:' ? 'https://localhost:9000' : 'http://127.0.0.1:9000');
  return normalizeBackend(els.backend.value || readLS(LS_KEY) || def);
}
function saveBackend(){
  const v = normalizeBackend(els.backend.value || '');
  if(!v) return;
  writeLS(LS_KEY, v);
  els.backend.value = v;
  status(`✅ Saved backend: ${v}`);
}
function loadBackend(){
  const def = (location.protocol === 'https:' ? 'https://localhost:9000' : 'http://127.0.0.1:9000');
  els.backend.value = normalizeBackend(readLS(LS_KEY) || def);
}

  // Build ID
  txt(els.buildInfo, window.__BUILD_ID__ || '—');

  // HTTP helper
  async function apiFetch(path, body){
    const base = getBackend();
    const url = base.replace(/\/+$/,'') + path;
    const cid = crypto.randomUUID ? crypto.randomUUID() : String(Math.random());
    const t0 = performance.now();
    const res = await fetch(url, {
      method:'POST',
      headers: {'content-type':'application/json','x-cid':cid},
      body: body ? JSON.stringify(body) : '{}'
    });
    const latency = Math.round(performance.now() - t0);
    S.lastLatency = latency;
    const schema = res.headers.get('x-schema-version') || '—';
    const xcache = res.headers.get('x-cache') || '—';
    txt(els.cidBadge, cid);
    txt(els.xcacheBadge, xcache);
    txt(els.latencyBadge, `${latency} ms`);
    txt(els.schemaBadge, schema);
    txt(els.doctorCid, cid);
    txt(els.doctorLatency, latency);
    S.lastCid = cid;

    let json;
    try { json = await res.json(); }
    catch(e){ throw new Error(`Bad JSON (${res.status})`) }

    // doctor info
    if (els.doctorReqList) {
      const li = document.createElement('li'); li.textContent = `${path} • ${latency}ms • ${json && (json.generated_at||'')}`;
      els.doctorReqList.prepend(li);
      const size = JSON.stringify(json).length;
      txt(els.doctorPayload, `${(size/1024).toFixed(1)} kB`);
    }
    if (!res.ok) throw new Error(`${res.status} • ${json && json.title || 'error'}`);
    return json;
  }

  // GET helper for /health
  async function apiGet(path){
    const base = getBackend();
    const url = base.replace(/\/+$/,'') + path;
    const t0 = performance.now();
    const res = await fetch(url, {method:'GET'});
    const latency = Math.round(performance.now() - t0);
    txt(els.latencyBadge, `${latency} ms`);
    const schema = res.headers.get('x-schema-version') || '—';
    txt(els.schemaBadge, schema);
    const json = await res.json();
    return {json, latency, schema, status:res.status};
  }

  // ---------- Rendering ----------
  function setBadges(a){
    txt(els.score, `score: ${a && a.score != null ? a.score : '—'}`);
    txt(els.risk, `risk: ${a && a.risk ? a.risk : (a && a.risk_level) || '—'}`);
    txt(els.status, `status: ${a && a.status ? a.status : '—'}`);
    // legacy severity may be absent; map from risk if needed
    const sev = a && (a.severity || (a.risk==='critical'?'high':a.risk));
    txt(els.severity, `severity: ${sev || '—'}`);
  }

  function renderAnalysis(legacy){
    if(!legacy){ return; }
    const a = legacy.analysis || {};
    setBadges(a);
    txt(els.resClauseType, a.clause_type || '—');
    const findings = Array.isArray(a.findings) ? a.findings : [];
    txt(els.resFindingsCount, findings.length);
    // Findings list
    els.findingsList.innerHTML = '';
    if (!findings.length) {
      const li=document.createElement('li'); li.textContent='No findings returned.'; els.findingsList.appendChild(li);
    } else {
      findings.forEach(f=>{
        const li=document.createElement('li');
        const sev = (f.severity || f.severity_level || '').toString();
        const emoji = (sev==='critical' || sev==='high' || sev==='major')?'🛑': (sev==='medium' || sev==='minor')?'⚠️':'ℹ️';
        li.textContent = `${emoji} [${f.code || 'CODE'}] ${f.message || ''}`;
        els.findingsList.appendChild(li);
      });
    }
    // Recommendations
    els.recsList.innerHTML='';
    const recs = Array.isArray(a.recommendations)? a.recommendations : [];
    if (!recs.length) {
      const li=document.createElement('li'); li.textContent='—'; els.recsList.appendChild(li);
    } else {
      recs.forEach(r=>{ const li=document.createElement('li'); li.textContent=String(r); els.recsList.appendChild(li); });
    }
    // Proposed text → draft box (if provided)
    if ((a.proposed_text||'').trim()){
      setVal(els.draft, a.proposed_text);
      enableApply(true);
    }
  }

  function setVal(el, v){ if(!el) return; el.value = (v==null?'':String(v)); }
  function enableApply(flag){
    if (els.btnPreview) els.btnPreview.disabled = !flag;
    if (els.btnApply) els.btnApply.disabled = !flag;
    if (els.btnAcceptAll) els.btnAcceptAll.disabled = !flag;
    if (els.btnRejectAll) els.btnRejectAll.disabled = !flag;
  }

  function fillClauseSelect(envelope){
    // Prefer SSOT titles if available
    S.clauseTitles = {};
    const doc = envelope.document || {};
    const idx = (doc.index && doc.index.clauses) || [];
    idx.forEach(c=>{
      if (c && c.id) S.clauseTitles[String(c.id)] = c.title || c.type || 'clause';
    });
    const clauses = envelope.clauses || [];
    els.sugSelect.innerHTML='';
    clauses.forEach(c=>{
      const opt = document.createElement('option');
      opt.value = c.id || '';
      const ttl = S.clauseTitles[c.id] || c.type || 'clause';
      opt.textContent = `${c.id || '—'} · ${ttl}`;
      els.sugSelect.appendChild(opt);
    });
  }

  // ---------- Actions ----------
  async function testBackend(){
    const {json, status} = await apiGet('/health');
    txt(els.connBadge, `Conn: ${status}`);
    status === 200 ? (els.connBadge.style.background='#184a2c') : (els.connBadge.style.background='#5b2b2b');
    status === 200 ? statusMsg('✅ Backend connected (200)') : statusMsg('❌ Backend not reachable');
    function statusMsg(m){ status(m); }
  }

  async function analyze(useDoc=false){
    let text = (els.clause.value||'').trim();
    if (useDoc) text = await readWholeDoc();
    if (!text){ status('⚠️ No text to analyze.'); return; }
    txt(els.rawJson, ''); els.rawJson.style.display='none';

    status('⏳ Analyzing…');
    const env = await apiFetch('/api/analyze', { text });
    S.lastAnalyze = env;
    S.lastLegacy = { analysis: env.analysis, results: env.results, clauses: env.clauses };
    S.lastDocument = env.document || {};
    renderAnalysis(S.lastLegacy);
    fillClauseSelect(env);

    // Status line already filled by apiFetch headers
    txt(els.doctorCid, S.lastCid||'—');
    status('✅ Analyze OK');
    // Raw toggle
    els.toggleRaw.onclick = () => {
      if (els.rawJson.style.display==='none'){
        els.rawJson.style.display='block';
        els.rawJson.textContent = JSON.stringify(env, null, 2);
      } else {
        els.rawJson.style.display='none';
      }
    };
  }

  async function getDraft(){
    const analysis = S.lastLegacy && S.lastLegacy.analysis ? S.lastLegacy.analysis : null;
    const text = (els.clause.value||'').trim();
    if (!analysis && !text){ status('⚠️ Nothing to draft. Paste text or run Analyze.'); return; }
    status('✍️ Drafting…');
    const env = await apiFetch('/api/gpt/draft', {
      text: analysis ? null : text,
      analysis: analysis || null,
      clause_type: analysis ? analysis.clause_type : undefined,
      mode: 'friendly'
    });
    const draft = (env && env.draft_text) || '';
    setVal(els.draft, draft);
    enableApply(!!draft);
    status(draft ? '✅ Draft OK' : '⚠️ Draft empty');
  }

  async function callSuggest(){
    if (!S.lastAnalyze){ status('⚠️ Run Analyze (doc) first.'); return; }
    const clauseId = els.sugSelect.value || '';
    const mode = els.sugMode.value || 'friendly';
    const fullText = await readWholeDoc();
    status(`🧩 Suggest for clause ${clauseId} in ${mode}…`);
    const env = await apiFetch('/api/suggest_edits', { text: fullText, clause_id: clauseId, mode, top_k: 3 });
    renderSuggestions(env && env.suggestions || []);
  }

  function renderSuggestions(list){
    els.sugList.innerHTML='';
    if (!Array.isArray(list) || !list.length){
      const div = document.createElement('div');
      div.className='muted'; div.textContent='No suggestions.';
      els.sugList.appendChild(div); return;
    }
    list.forEach((sug, i)=>{
      const card = document.createElement('div'); card.className='sug-card';
      const head = document.createElement('div'); head.className='sug-head';
      const title = document.createElement('div'); title.className='sug-title'; title.textContent = sug.title || `Suggestion ${i+1}`;
      const meta = document.createElement('div'); meta.className='sug-meta'; meta.textContent = (sug.risk?`risk:${sug.risk}`:'');
      head.appendChild(title); head.appendChild(meta);
      const pre = document.createElement('pre'); pre.textContent = sug.draft || sug.proposed_text || '';
      const row = document.createElement('div');
      const btn = document.createElement('button'); btn.className='btn'; btn.textContent='Apply → Draft';
      btn.onclick = ()=>{ setVal(els.draft, pre.textContent); enableApply(!!pre.textContent); status('📝 Suggestion copied to draft. Review then Apply.'); };
      row.appendChild(btn);
      card.appendChild(head); card.appendChild(pre); card.appendChild(row);
      els.sugList.appendChild(card);
    });
  }

  // ---------- Office.js helpers ----------
  async function readSelection(){
    if (!window.Word || !Word.run){ status('⚠️ Word API not available'); return ''; }
    return Word.run(async ctx=>{
      const sel = ctx.document.getSelection(); sel.load('text'); await ctx.sync(); return sel.text || '';
    });
  }
  async function readWholeDoc(){
    if (!window.Word || !Word.run){ return (els.clause.value||'').trim(); }
    return Word.run(async ctx=>{
      const body = ctx.document.body; body.load('text'); await ctx.sync(); return body.text || '';
    });
  }
  async function insertIntoWord(){
    const text = (els.draft.value||'').trim(); if (!text){ status('⚠️ Draft empty'); return; }
    if (!window.Word || !Word.run){ status('⚠️ Word API not available'); return; }
    await Word.run(async ctx=>{
      const range = ctx.document.getSelection(); range.insertText(text, 'Replace'); await ctx.sync();
    });
    status('✅ Inserted into Word (no tracking)');
  }

  async function applyDraftTracked(){
    const text = (els.draft.value||'').trim(); if (!text){ status('⚠️ Draft empty'); return; }
    if (!window.Word || !Word.run){ status('⚠️ Word API not available'); return; }
    await Word.run(async ctx=>{
      try{
        // Turn track changes on
        if (ctx.document && ctx.document.changeTrackingMode){
          ctx.document.changeTrackingMode = 'TrackAll';
        }
      }catch(e){}
      const range = ctx.document.getSelection();
      range.insertText(text, 'Replace');
      // Add a comment
      try { range.insertComment('Contract AI — applied draft'); } catch(e){}
      await ctx.sync();
    });
    status('✅ Applied with tracked changes');
    enableApply(true);
  }

  async function acceptAllChanges(){
    if (!window.Word || !Word.run){ status('⚠️ Word API not available'); return; }
    await Word.run(async ctx=>{
      try{ ctx.document.acceptAllChanges(); }catch(e){}
      await ctx.sync();
    });
    status('✅ Accepted all changes');
  }
  async function rejectAllChanges(){
    if (!window.Word || !Word.run){ status('⚠️ Word API not available'); return; }
    await Word.run(async ctx=>{
      try{ ctx.document.rejectAllChanges(); }catch(e){}
      await ctx.sync();
    });
    status('✅ Rejected all changes');
  }

  async function annotate(){
    const legacy = S.lastLegacy;
    if (!legacy || !legacy.analysis){ status('⚠️ Analyze first.'); return; }
    const threshold = (els.riskThreshold.value||'high');
    const items = Array.isArray(legacy.analysis.findings)? legacy.analysis.findings : [];
    if (!window.Word || !Word.run){ status('⚠️ Word API not available'); return; }
    const docText = await readWholeDoc();

    await Word.run(async ctx=>{
      const body = ctx.document.body;
      for (const f of items){
        const rk = (f.risk || f.severity || 'medium').toString().toLowerCase();
        const rank = {'low':0,'medium':1,'high':2,'critical':3}[rk] ?? 1;
        const thr  = {'low':0,'medium':1,'high':2,'critical':3}[threshold] ?? 2;
        if (rank < thr) continue;
        // Try to anchor by snippet
        const snippet = (f.evidence && String(f.evidence).slice(0,50)) || (f.message && String(f.message).slice(0,50)) || '';
        if (snippet){
          const found = body.search(snippet, {matchCase:false});
          found.load('items');
          await ctx.sync();
          if (found.items.length){
            try { found.items[0].insertComment(`[${f.code||'ISSUE'}] ${f.message||''} — risk:${rk}`); } catch(e){}
            continue;
          }
        }
        // Fallback: comment at selection start
        try { ctx.document.getSelection().insertComment(`[${f.code||'ISSUE'}] ${f.message||''} — risk:${rk}`);} catch(e){}
      }
      await ctx.sync();
    });
    status('✅ Annotated (comments added)');
  }

  async function clearAnnots(){
    if (!window.Word || !Word.run){ status('⚠️ Word API not available'); return; }
    await Word.run(async ctx=>{
      try{
        const comments = ctx.document.body.comments; comments.load('items'); await ctx.sync();
        for (const c of comments.items){ try{ c.delete(); }catch(e){} }
      }catch(e){}
      await ctx.sync();
    });
    status('🧹 Cleared annotations');
  }

  async function qaRecheck(){
    const fullText = await readWholeDoc();
    status('🔁 QA recheck…');
    const env = await apiFetch('/api/qa-recheck', { text: fullText, applied_changes: [] });
    // env: { deltas: {score_delta,risk_delta,status_from,status_to}, residual_risks: [...] }
    const d = env && env.deltas || {};
    txt(els.qaDeltaBadge, `Δ: s${d.score_delta>=0?'+':''}${d.score_delta||0} r${d.risk_delta>=0?'+':''}${d.risk_delta||0} ${d.status_from||''}→${d.status_to||''}`);
    const residuals = (env && env.residual_risks) || [];
    els.qaResidualList.innerHTML='';
    if (residuals.length){
      els.qaResiduals.style.display='block';
      residuals.forEach(r=>{
        const li = document.createElement('li');
        li.textContent = `[${r.code||'GEN'}] ${r.message||''}`;
        els.qaResidualList.appendChild(li);
      });
    } else {
      els.qaResiduals.style.display='none';
    }
    status('✅ QA recheck done');
  }

  // ---------- Wire UI ----------
  function wire(){
    if (els.btnSave) els.btnSave.onclick = saveBackend;
    if (els.btnTest) els.btnTest.onclick = ()=>testBackend().catch(e=>status('❌ '+e.message));
    if (els.analyzeBtn) els.analyzeBtn.onclick = ()=>analyze(false).catch(e=>status('❌ '+e.message));
    if (els.btnAnalyzeDoc) els.btnAnalyzeDoc.onclick = ()=>analyze(true).catch(e=>status('❌ '+e.message));
    if (els.draftBtn) els.draftBtn.onclick = ()=>getDraft().catch(e=>status('❌ '+e.message));
    if (els.copyBtn) els.copyBtn.onclick = ()=>{ navigator.clipboard && navigator.clipboard.writeText(els.draft.value||''); status('📋 Draft copied'); };
    if (els.useSel) els.useSel.onclick = async ()=>{ const t=await readSelection(); setVal(els.clause, t); status('Selection copied.'); };
    if (els.useDoc) els.useDoc.onclick = async ()=>{ const t=await readWholeDoc(); setVal(els.clause, t); status('Whole document copied.'); };
    if (els.insertWord) els.insertWord.onclick = ()=>insertIntoWord().catch(e=>status('❌ '+e.message));
    if (els.btnApply) els.btnApply.onclick = ()=>applyDraftTracked().catch(e=>status('❌ '+e.message));
    if (els.btnPreview) els.btnPreview.onclick = ()=>{ alert('Preview: compare Original clause and Draft visually in Word track-changes.'); };
    if (els.btnAcceptAll) els.btnAcceptAll.onclick = ()=>acceptAllChanges().catch(e=>status('❌ '+e.message));
    if (els.btnRejectAll) els.btnRejectAll.onclick = ()=>rejectAllChanges().catch(e=>status('❌ '+e.message));
    if (els.btnAnnotate) els.btnAnnotate.onclick = ()=>annotate().catch(e=>status('❌ '+e.message));
    if (els.btnClearAnnots) els.btnClearAnnots.onclick = ()=>clearAnnots().catch(e=>status('❌ '+e.message));
    if (els.btnQARecheck) els.btnQARecheck.onclick = ()=>qaRecheck().catch(e=>status('❌ '+e.message));
    if (els.sugBtn) els.sugBtn.onclick = ()=>callSuggest().catch(e=>status('❌ '+e.message));
    if (els.toggleRaw) els.toggleRaw.onclick = ()=>{ /* set in analyze */ };

    // Doctor toggle
    if (els.doctorToggle) els.doctorToggle.onclick = ()=>{
      const vis = els.doctorPanel.style.display!=='none';
      els.doctorPanel.style.display = vis ? 'none' : 'block';
      els.doctorToggle.textContent = vis ? 'Doctor ▸' : 'Doctor ▾';
    };
  }

  // ---------- Boot ----------
  loadBackend();
  wire();
  txt(els.officeBadge, 'Office: init…');
  if (window.Office && Office.onReady){
    Office.onReady(info=>{
      txt(els.officeBadge, `Office: ${info && info.host || 'Ready'}`);
    });
  } else {
    txt(els.officeBadge, 'Office: (deferred)');
  }
  status('🟢 Panel ready. Set backend and click Test.');
})();
</script>
</body>
</html>
